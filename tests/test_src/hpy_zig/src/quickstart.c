// quickstart.c

// This header file is the entrypoint to the HPy API:
//#define HPY_ABI_UNIVERSAL
#include "hpy.h"

// HPy method: the HPyDef_METH macro generates some boilerplate code,
// the same code can be also written manually if desired
// So let's do that!
// Original Macro call:

// HPyDef_METH(say_hello, "say_hello", HPyFunc_NOARGS)

// HPyDef_METH definition:
//
// HPyDef_METH unrolled once:

//HPyDef_METH_IMPL(say_hello, "say_hello", say_hello_impl, HPyFunc_NOARGS) // __VA_ARGS__ not used here!

// unrolled twice:

//HPyFunc_DECLARE(say_hello_impl, HPyFunc_NOARGS);
//HPyFunc_TRAMPOLINE(say_hello_trampoline, say_hello_impl, HPyFunc_NOARGS)
//HPyDef say_hello = {
//  .kind = HPyDef_Kind_Meth,
//  .meth = {
//    .name = "say_hello",
//    .impl = (HPyCFunction)say_hello_impl,
//    .cpy_trampoline = (cpy_PyCFunction)say_hello_trampoline,
//    .signature = HPyFunc_NOARGS
//    // __VAR_ARGS__
//  }
//};

// unrolled thrice:

//enum { say_hello_impl_sig = HPyFunc_NOARGS };  // Where is HPyFunc_NOARGS defined?
//_HPyFunc_DECLARE_HPyFunc_NOARGS(say_hello_impl); // autogenerated macro
//
//enum { say_hello_trampoline_sig = HPyFunc_NOARGS }; 
//_HPyFunc_TRAMPOLINE_HPyFunc_NOARGS(say_hello_trampoline, say_hello_impl); // autogenerated macro
//
//HPyDef say_hello = {
//  .kind = HPyDef_Kind_Meth,
//  .meth = {
//    .name = "say_hello",
//    .impl = (HPyCFunction)say_hello_impl,
//    .cpy_trampoline = (cpy_PyCFunction)say_hello_trampoline,
//    .signature = HPyFunc_NOARGS
//    // __VAR_ARGS__
//  }
//};

// unrolled a third time:

enum { say_hello_impl_sig = HPyFunc_NOARGS };  // HPyFunc_NOARGS is an enum defined in hpyfunc.h
static HPy say_hello_impl(HPyContext *ctx, HPy self); // Function prototype for use in trampoline.

enum { say_hello_trampoline_sig = HPyFunc_NOARGS }; 
static cpy_PyObject *say_hello_trampoline(cpy_PyObject *self) 
{
  _HPyFunc_args_NOARGS a = {self};
  _HPy_CallRealFunctionFromTrampoline(
    _ctx_for_trampolines, HPyFunc_NOARGS, (HPyCFunction) say_hello_impl, &a);
  return a.result;
}

HPyDef say_hello = {
  .kind = HPyDef_Kind_Meth,
  .meth = {
    .name = "say_hello",
    .impl = (HPyCFunction)say_hello_impl,
    .cpy_trampoline = (cpy_PyCFunction)say_hello_trampoline,
    .signature = HPyFunc_NOARGS
    // __VAR_ARGS__
  }
};
// Need to build in Zig:
// import hpy enums (HPyFunc_*, HPyDef_Kind_Meth)
// import hpy typedefs:
//    PyObject
//    HPyContext
//    cpy_PyObject
//    HPyCFunction
//    cpy_PyCFunction
//    HPyDef
//
// zig User API:
// -------------------------------------------------------------------------------------------------
//
// HPyDef_METH("my_function", HPyFunc_NOARGS)
// export fn my_function_impl(HPyContext *ctx, HPy self)
//
// -------------------------------------------------------------------------------------------------
//
// HPyDef_METH(func_name: []const u8, func_sig: u16) void {
//    @export:  {func_name}_impl_sig        (HPyFunc_{SIG} enum)
//    @export:  {func_name}_impl            (HPy function)
//    @export:  {func_name}_trampoline_sig  (HPyFunc_{SIG} enum)
//    @export: *{func_name}_trampoline      (cpy_PyObject function)
//    @export:  {func_name}                 (HPyDef struct)
// }
//
// -------------------------------------------------------------------------------------------------
//
//  Some ideas:
//
//  Autogeneration: Much of HPy is autogenerated macros. Is there a good way to automatically keep up
//  with this? It's not a good idea to reimplement a lot of HPy functionality since it's autogen and
//  the API will be updated, fix, and expanded. Is it possible to use Zig to import hpy.h, auto
//  generate the symbols that are created by the macros, and call into the HPy C functions?
//
//  Zig specific functionality: Are there any functions that would benefit from being added?
//  It could be nice to automatically move between Python objects and Zig builtin types without
//  invoking any C types. Maybe some of these can just be wrappers around the C code?
//
//  Autogen Python bindings to Zig: How hard would it be to autogenerate Python bindings for any
//  given Zig library + names of functions to export? May need to constrain function parameters
//  and return types to a list of known types. But with that constraint, is it still worth it?
//  Is this already possible with SWIG?
//
static HPy say_hello_impl(HPyContext *ctx, HPy self)
{
    // Methods take HPyContext, which must be passed as the first argument to
    // all HPy API functions. Other than that HPyUnicode_FromString does the
    // same thing as PyUnicode_FromString.
    //
    // HPy type represents a "handle" to a Python object, but may not be
    // a pointer to the object itself. It should be fully "opaque" to the
    // users. Try uncommenting the following two lines to see the difference
    // from PyObject*:
    //
    // if (self == self)
    //      HPyUnicode_FromString(ctx, "Surprise? Try HPy_Is(ctx, self, self)");

    return HPyUnicode_FromString(ctx, "Hello world!");
}

// Is this important? Can we just ask for a tuple of function pointers?
static HPyDef *QuickstartMethods[] = {
    &say_hello, // 'say_hello' generated for us by the HPyDef_METH macro
    NULL,
};

// This should stay. This gives the user the ability to define aspects of the module.
static HPyModuleDef quickstart_def = {
    .doc = "HPy Quickstart Example",
    .defines = QuickstartMethods,
};

// The Python interpreter will create the module for us from the
// HPyModuleDef specification. Additional initialization can be
// done in the HPy_mod_execute slot
//HPy_MODINIT(quickstart, quickstart_def)

// unrolled once:

//HPy_EXPORTED_FUNC uint32_t // HPy_EXPORTED_FUNC is only used for C++ compilers. Not needed for Zig.
//get_required_hpy_major_version_quickstart()
//{
//  return HPY_ABI_VERSION;
//}
//HPy_EXPORTED_FUNC uint32_t
//get_required_hpy_minor_version_quickstart()
//{
//  return HPY_ABI_VERSION_MINOR;
//}
//_HPy_CTX_MODIFIER HPyContext *_ctx_for_trampolines; // _HPy_CTX_MODIFIER declares an attribute for the compiler
//HPy_EXPORTED_FUNC void
//HPyInitGlobalContext_quickstart(HPyContext *ctx)
//{
//  _ctx_for_trampolines = ctx;
//}
//HPy_EXPORTED_FUNC HPyModuleDef*
//HPyInit_quickstart()
//{
//  return &quickstart_def;
//}

// unrolled twice:

// NOTE: This is specifically for the universal/hybrid ABI. cpython ABI is smaller

HPy_EXPORTED_SYMBOL uint32_t  // HPy_EXPORTED_SYMBOL used for __declspec or __attribute__ calls
get_required_hpy_major_version_quickstart()
{
  return HPY_ABI_VERSION; // HPY_ABI_VERSION should be dynamically set from HPy package version
}
HPy_EXPORTED_SYMBOL uint32_t
get_required_hpy_minor_version_quickstart()
{
  return HPY_ABI_VERSION_MINOR; // HPY_ABI_VERSION_MINOR should be dynamically set from HPy package version
}
_HPy_HIDDEN HPyContext *_ctx_for_trampolines; // _HPy_HIDDEN declares the hidden __attribute__
HPy_EXPORTED_SYMBOL void
HPyInitGlobalContext_quickstart(HPyContext *ctx)
{
  _ctx_for_trampolines = ctx;
}
HPy_EXPORTED_SYMBOL HPyModuleDef*
HPyInit_quickstart()
{
  return &quickstart_def;
}

// Need to get these:
//    HPy_ABI_VERSION (macro or alternate?)
//    HPy_ABI_VERSION_MINOR (macro or alternate?)
//    HPyModuleDef*
//    HPyContext
//
// Zig User API:
// -------------------------------------------------------------------------------------------------
//
// HPy_MODINIT("my_module", quickstart_def);
//    
// -------------------------------------------------------------------------------------------------
//
// Implementation:
//
// HPy_MODINIT(modulename: []const u8, module_def: HPyDef)
//    @export get_required_hpy_major_version_{modulename} (function u32)
//    @export get_required_hpy_minor_version_{modulename} (function u32)
//    @export HPyInitGlobalContext_{modulename}           (function void)
//    @export HPyInit_{modulename}                        (function HPyModuleDef*)
//


