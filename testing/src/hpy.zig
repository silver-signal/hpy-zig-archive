const std = @import("std");

const hpy = @cImport({
    @cDefine("HPY", {});
    @cDefine("HPY_ABI_UNIVERSAL", {});
    @cInclude("hpy.h");
});

pub const HPY_ABI_VERSION = hpy.HPY_ABI_VERSION;
pub const HPY_ABI_VERSION_MINOR = hpy.HPY_ABI_VERSION_MINOR;

pub const HPy = hpy.HPy;
pub const HPyDef = hpy.HPyDef;
pub const HPyDef_Kind = hpy.HPyDef_Kind;
pub const HPyDef_Kind_Slot = hpy.HPyDef_Kind_Slot;
pub const HPyDef_Kind_Meth = hpy.HPyDef_Kind_Meth;
pub const HPyDef_Kind_Member = hpy.HPyDef_Kind_Member;
pub const HPyDef_Kind_GetSet = hpy.HPyDef_Kind_GetSet;
pub const HPySlot = hpy.HPySlot;
pub const HPyMeth = hpy.HPyMeth;
pub const HPyMember = hpy.HPyMember;
pub const HPyGetSet = hpy.HPyGetSet;

pub const HPyContext = hpy.HPyContext;
pub const HPyCFunction = hpy.HPyCFunction;
pub const cpy_PyCFunction = hpy.cpy_PyCFunction;
pub const cpy_PyObject = hpy.cpy_PyObject;
pub const _HPy_CallRealFunctionFromTrampoline = hpy._HPy_CallRealFunctionFromTrampoline;

pub const HPyModuleDef = hpy.HPyModuleDef;

pub const HPyFunc_NOARGS = hpy.HPyFunc_NOARGS;
pub const _HPyFunc_args_NOARGS = hpy._HPyFunc_args_NOARGS;

pub const HPyUnicode_FromString = hpy.HPyUnicode_FromString;

//extern var _ctx_for_trampolines: *HPyContext;

pub inline fn HPyDef_METH(meth_name: []const u8, meth_sig: c_int) void {
    comptime {
        std.debug.print("{s}\n", .{meth_name});
        std.debug.print("{d}\n", .{meth_sig});
        // TODO: make extern enum for function signatures

    }
}

// TODO: makeHPyFuncEnum. These enums are generated by HPy macros, but are not used(?).
// Is this necessary?

/// Creates the module trampline function
pub fn makeMethodTrampoline() fn () *cpy_PyObject {
    const S = struct {
        fn methodTrampoline(self: *cpy_PyObject) *cpy_PyObject {
            //var a: _HPyFunc_args_NOARGS a = {self};
            //_HPy_CallRealFunctionFromTrampoline();
            return self;
        }
    };
    return S.methodTrampoline;
}

/// Creates an HPyDef struct with a custom name and kind
pub fn makeHPyDef(name: []const u8, kind: HPyDef_Kind) HPyDef {
    std.debug.print("{s}\n", .{name});
    var newHPyDef = HPyDef{
        .kind = kind,
    };
    return newHPyDef;
}

/// Return a HPyDef type (Slot, Meth, Member, or GetSet) based on parameters:
//fn makeHPyDef_Kind(kind: HPyDef_Kind)

// TODO
//fn makeHPySlot()

// FIXME: How does one pass a function ptr which could take any params,
//      and return any type? That /should/ be the type of impl and trampoline.
//fn makeHPyMeth(name: []const u8, impl: anytype, trampoline: anytype) {
//    var newHPyMeth = HPyMeth{
//        .name = name,
//        .impl = impl,
//        .signature =
//    };
//    return newHPyMeth;
//}

// TODO
//fn makeHPyMember()

// TODO
//fn makeHPyGetSet()

pub inline fn HPy_MODINIT(comptime ext_name: []const u8, comptime mod_def: HPyModuleDef) void {
    comptime {
        const getMajorVersion = makeGetRequiredHPyVersion(HPY_ABI_VERSION);
        const get_major_version_func_name = "get_required_hpy_major_version_" ++ ext_name;
        @export(getMajorVersion, .{
            .name = get_major_version_func_name,
            .linkage = .Strong,
        });

        const getMinorVersion = makeGetRequiredHPyVersion(HPY_ABI_VERSION_MINOR);
        const get_minor_version_func_name = "get_required_hpy_minor_version_" ++ ext_name;
        @export(getMinorVersion, .{
            .name = get_minor_version_func_name,
            .linkage = .Strong,
        });

        _ = mod_def;
        //const HPyInitModule = makeHPyInit(mod_def);
        //const HPyInitModuleFuncName = "HPyInit_" ++ ext_name;
        //@export(HPyInitModule, .{
        //    .name = HPyInitModuleFuncName,
        //    .linkage = .Strong,
        //});

        //        const ModuleContext = makeHPyInitGlobalContextStruct();
        //        const initContext = ModuleContext.HPyInitGlobalContext;
        //        const initContextFuncName = "HPyInitGlobalContext_" ++ ext_name;
        //        @export(initContext, .{
        //            .name = initContextFuncName,
        //            .linkage = .Strong,
        //        });

        //        return ModuleContext;
    }
}

/// Return a function which returns the required HPy version
pub fn makeGetRequiredHPyVersion(comptime hpy_version: u32) fn () callconv(.C) u32 {
    const S = struct {
        pub fn getRequiredHPyVersion() callconv(.C) u32 {
            return hpy_version;
        }
    };
    return S.getRequiredHPyVersion;
}

/// Create a function which allows HPy to set the global context
pub fn makeHPyInitGlobalContextStruct() type {
    const S = struct {
        pub var _ctx_for_trampolines = null;
        pub fn HPyInitGlobalContext(ctx: *HPyContext) callconv(.C) void {
            _ctx_for_trampolines = ctx;
        }
    };
    return S;
}

/// Create a function to send the module definition to HPy
pub fn makeHPyInit(comptime mod_def: HPyModuleDef) fn () callconv(.C) [*c]HPyModuleDef {
    const S = struct {
        pub fn HPyInit() callconv(.C) [*c]HPyModuleDef {
            return &mod_def;
        }
    };
    return S.HPyInit;
}
