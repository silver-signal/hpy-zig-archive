const std = @import("std");

const hpy = @cImport({
    @cDefine("HPY", {});
    @cDefine("HPY_ABI_UNIVERSAL", {});
    @cInclude("hpy.h");
});

pub const HPY_ABI_VERSION = hpy.HPY_ABI_VERSION;
pub const HPY_ABI_VERSION_MINOR = hpy.HPY_ABI_VERSION_MINOR;

const HPySlot = hpy.HPySlot;
const HPyMeth = hpy.HPyMeth;
const HPyMember = hpy.HPyMember;
const HPyGetSet = hpy.HPyGetSet;
const HPyDef = hpy.HPyDef;
const HPyDef_Kind = hpy.HPyDef_Kind;
const HPyDef_Kind_Slot = hpy.HPyDef_Kind_Slot;
const HPyDef_Kind_Meth = hpy.HPyDef_Kind_Meth;
const HPyDef_Kind_Member = hpy.HPyDef_Kind_Member;
const HPyDef_Kind_GetSet = hpy.HPyDef_Kind_GetSet;

const HPyContext = hpy.HPyContext;
const HPyModuleDef = hpy.HPyModuleDef;
const cpy_PyObject = hpy.cpy_PyObject;
const _HPy_CallRealFunctionFromTrampoline = hpy._HPy_CallRealFunctionFromTrampoline;

extern var _ctx_for_trampolines: *HPyContext;

pub fn HPyDef_METH(meth_name: []const u8, meth_sig: c_int) void {
    comptime {
        std.debug.print("{s}\n", .{meth_name});
        std.debug.print("{d}\n", .{meth_sig});
        // TODO: make extern enum for function signatures

    }
}

// TODO: makeHPyFuncEnum. These enums are generated by HPy macros, but are not used(?).
// Is this necessary?

/// Creates the module trampline function
fn makeMethodTrampoline() fn () *cpy_PyObject {
    const S = struct {
        fn methodTrampoline(self: *cpy_PyObject) *cpy_PyObject {
            //var a: _HPyFunc_args_NOARGS a = {self};
            //_HPy_CallRealFunctionFromTrampoline();
            return self;
        }
    };
    return S.methodTrampoline;
}

/// Creates an HPyDef struct with a custom name and kind
fn makeHPyDef(name: []const u8, kind: HPyDef_Kind) HPyDef {
    std.debug.print("{s}\n", .{name});
    var newHPyDef = HPyDef{
        .kind = kind,
    };
    return newHPyDef;
}

const HPyDef_Union = union {
    slot: HPySlot,
    meth: HPyMeth,
    member: HPyMember,
    getset: HPyGetSet,
};

/// Return a HPyDef type (Slot, Meth, Member, or GetSet) based on parameters:
//fn makeHPyDef_Kind(kind: HPyDef_Kind)

// TODO
//fn makeHPySlot()

// FIXME: How does one pass a function ptr which could take any params,
//      and return any type? That /should/ be the type of impl and trampoline.
//fn makeHPyMeth(name: []const u8, impl: anytype, trampoline: anytype) {
//    var newHPyMeth = HPyMeth{
//        .name = name,
//        .impl = impl,
//        .signature =
//    };
//    return newHPyMeth;
//}

// TODO
//fn makeHPyMember()

// TODO
//fn makeHPyGetSet()

pub inline fn HPy_MODINIT(ext_name: []const u8, mod_def: HPyModuleDef) void {
    comptime {
        const getMajorVersion = makeGetRequiredHPyVersion(HPY_ABI_VERSION);
        const getMajorVersionFuncName = "get_required_hpy_major_version_" ++ ext_name;
        @export(getMajorVersion, .{
            .name = getMajorVersionFuncName,
            .linkage = .Strong,
        });

        const getMinorVersion = makeGetRequiredHPyVersion(HPY_ABI_VERSION_MINOR);
        const getMinorVersionFuncName = "get_required_hpy_minor_version_" ++ ext_name;
        @export(getMinorVersion, .{
            .name = getMinorVersionFuncName,
            .linkage = .Strong,
        });

        const initContext = makeHPyInitGlobalContext();
        const initContextFuncName = "HPyInitGlobalContext_" ++ ext_name;
        @export(initContext, .{
            .name = initContextFuncName,
            .linkage = .Strong,
        });

        const HPyInitModule = makeHPyInit(mod_def);
        const HPyInitModuleFuncName = "HPyInit_" ++ ext_name;
        @export(HPyInitModule, .{
            .name = HPyInitModuleFuncName,
            .linkage = .Strong,
        });
    }
}

/// Return a function which returns the required HPy version
fn makeGetRequiredHPyVersion(comptime hpy_version: u32) fn () u32 {
    const S = struct {
        fn getRequiredHPyVersion() u32 {
            return hpy_version;
        }
    };
    return S.getRequiredHPyVersion;
}

/// Create a function which allows HPy to set the global context
fn makeHPyInitGlobalContext() fn () void {
    const S = struct {
        fn HPyInitGlobalContext(ctx: *HPyContext) void {
            _ctx_for_trampolines = ctx;
        }
    };
    return S.HPyInitGlobalContext;
}

/// Create a function to send the module definition to HPy
fn makeHPyInit(mod_def: HPyModuleDef) fn () *HPyModuleDef {
    const S = struct {
        fn HPyInit() *HPyModuleDef {
            return &mod_def;
        }
    };
    return S.HPyInit;
}
