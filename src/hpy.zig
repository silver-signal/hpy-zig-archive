const std = @import("std");

const hpy = @cImport({
    @cDefine("HPY", {});
    @cDefine("HPY_ABI_UNIVERSAL", {});
    @cInclude("hpy.h");
});

pub const HPY_ABI_VERSION = hpy.HPY_ABI_VERSION;
pub const HPY_ABI_VERSION_MINOR = hpy.HPY_ABI_VERSION_MINOR;
const HPyDef = hpy.HPyDef;
const HPyContext = hpy.HPyContext;
const HPyModuleDef = hpy.HPyModuleDef;
const cpy_PyObject = hpy.cpy_PyObject;
const _HPy_CallRealFunctionFromTrampoline = hpy._HPy_CallRealFunctionFromTrampoline;

extern var _ctx_for_trampolines: *HPyContext;

pub fn HPyDef_METH(meth_name: []const u8, meth_sig: c_int) void {
    comptime {
        std.debug.print("{s}\n", .{meth_name});
        std.debug.print("{d}\n", .{meth_sig});
        // TODO: make extern enum for function signatures

    }
}

// TODO: makeHPyFuncEnum. These enums are generated by HPy macros, but are not used(?).
// Is this necessary?

/// Creates the module trampline function
//fn makeMethodTrampoline() fn () *cpy_PyObject {
//    const S = struct {
//        fn methodTrampoline(self: *cpy_PyObject) *cpy_PyObject {
//            //var a: _HPyFunc_args_NOARGS a = {self};
//            //_HPy_CallRealFunctionFromTrampoline();
//            return self;
//        }
//    };
//    return S.methodTrampoline;
//}
//
//fn makeHPyDef(name: []const u8, kind: HPyDef_Kind) HPyDef {
//    std.debug.print("{s}\n", .{name});
//    _ = kind;
//    var newHPyDef = HPydef{
//        .kind = kind,
//    };
//    return newHPyDef;
//}

pub inline fn HPy_MODINIT(ext_name: []const u8, mod_def: HPyModuleDef) void {
    comptime {
        const getMajorVersion = makeGetRequiredHPyVersion(HPY_ABI_VERSION);
        const getMajorVersionFuncName = "get_required_hpy_major_version_" ++ ext_name;
        @export(getMajorVersion, .{
            .name = getMajorVersionFuncName,
            .linkage = .Strong,
        });

        const getMinorVersion = makeGetRequiredHPyVersion(HPY_ABI_VERSION_MINOR);
        const getMinorVersionFuncName = "get_required_hpy_minor_version_" ++ ext_name;
        @export(getMinorVersion, .{
            .name = getMinorVersionFuncName,
            .linkage = .Strong,
        });

        const initContext = makeHPyInitGlobalContext();
        const initContextFuncName = "HPyInitGlobalContext_" ++ ext_name;
        @export(initContext, .{
            .name = initContextFuncName,
            .linkage = .Strong,
        });

        const HPyInitModule = makeHPyInit(mod_def);
        const HPyInitModuleFuncName = "HPyInit_" ++ ext_name;
        @export(HPyInitModule, .{
            .name = HPyInitModuleFuncName,
            .linkage = .Strong,
        });
    }
}

/// Return a function which returns the required HPy version
fn makeGetRequiredHPyVersion(comptime hpy_version: u32) fn () u32 {
    const S = struct {
        fn getRequiredHPyVersion() u32 {
            return hpy_version;
        }
    };
    return S.getRequiredHPyVersion;
}

/// Create a function which allows HPy to set the global context
fn makeHPyInitGlobalContext() fn () void {
    const S = struct {
        fn HPyInitGlobalContext(ctx: *HPyContext) void {
            _ctx_for_trampolines = ctx;
        }
    };
    return S.HPyInitGlobalContext;
}

/// Create a function to send the module definition to HPy
fn makeHPyInit(mod_def: HPyModuleDef) fn () *HPyModuleDef {
    const S = struct {
        fn HPyInit() *HPyModuleDef {
            return &mod_def;
        }
    };
    return S.HPyInit;
}
